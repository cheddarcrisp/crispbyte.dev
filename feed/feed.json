{
	"version": "https://jsonfeed.org/version/1.1",
	"title": "Crisp Byte",
	"language": "en",
	"home_page_url": "https://crispbyte.dev/",
	"feed_url": "https://crispbyte.dev/feed/feed.json",
	"description": "Programming. Puns.",
	"author": {
		"name": "CheddarCrisp",
		"url": "https://crispbyte.dev/about-me/"
	},
	"items": [
		{
			"id": "https://crispbyte.dev/blog/2024-01-09-03-Improvements/",
			"url": "https://crispbyte.dev/blog/2024-01-09-03-Improvements/",
			"title": "Improvements",
			"content_html": "<h2 id=\"format\" tabindex=\"-1\">Format <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-09-03-Improvements/\">#</a></h2>\n<ol>\n<li>QPACK might be better than HPACK, but I can't find a .NET implementation of QPACK.</li>\n<li>Both QPACK and HPACK use a static table designed for compressing the most common headers on the web. A different static table designed for SDBD could compress things better.</li>\n<li>For better interaction with streams, I want to change the metadata length value from number of bytes to number of headers. We know how many headers there are before we start encoding them. We don't know how many bytes the result will be until encoding is done.</li>\n<li>Also 64KB of header data is possible, but having over 64K headers shouldn't happen. Even 256 headers seems absurd, so maybe number of headers could be shrunk to one byte.</li>\n</ol>\n<h2 id=\"demo-implementation\" tabindex=\"-1\">Demo Implementation <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-09-03-Improvements/\">#</a></h2>\n<ol>\n<li>The proof of concept could use tests, error handling, data validation, and a fix for the warnings. At the least, validate the <code>content-name</code> so nobody can do anything hacky with it.</li>\n<li>It shouldn't be hard to add <code>content-type</code> to the demo output.</li>\n<li>I think a reference API built around streams instead of byte arrays would feel nicer.</li>\n<li>Wrangling the <code>hpack</code> NuGet package to work around streams might take some effort.</li>\n<li>Also a spec-compliant version of <code>Document</code>. <code>Dictionary&lt;string, string&gt;</code> breaks all three rules for headers listed back in <a href=\"https://crispbyte.dev/blog/2024-01-07-02-Semantics\">Semantics</a>.</li>\n</ol>\n",
			"date_published": "2024-01-09T00:00:00Z"
		}
		,
		{
			"id": "https://crispbyte.dev/blog/2024-01-09-02-The_Heart_of_the_Code/",
			"url": "https://crispbyte.dev/blog/2024-01-09-02-The_Heart_of_the_Code/",
			"title": "The Heart of the Code",
			"content_html": "<p>To complete the proof of concept we need to implement <code>SDBD.ICodec</code>. This is what we're proving after all. The most complicated part will be the HPACK encoding. I'd rather not implement that myself, not for something basic. Fortunately there is a NuGet package that should do the trick. It's called simply <code>hpack</code>.</p>\n<p>At the risk of pulling a <a href=\"https://knowyourmeme.com/memes/how-to-draw-an-owl\">&quot;rest of the owl&quot;</a>, I'm going to jump straight to the final code. I think a short walkthrough is enough to show how the code works without going through the coding process step by step.</p>\n<h2 id=\"encoder\" tabindex=\"-1\">Encoder <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-09-02-The_Heart_of_the_Code/\">#</a></h2>\n<pre class=\"language-cs\" tabindex=\"0\"><code class=\"language-cs\"><span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> <span class=\"token function\">Encode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Document</span> document<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> dataLength <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span>Data<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> contentLength <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Dictionary<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">string</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">string</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token string\">\"content-length\"</span><span class=\"token punctuation\">,</span> dataLength<span class=\"token punctuation\">.</span><span class=\"token function\">ToString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> headers <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span>Metadata<span class=\"token punctuation\">.</span><span class=\"token function\">Union</span><span class=\"token punctuation\">(</span>contentLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> packedHeaders <span class=\"token operator\">=</span> <span class=\"token function\">packHeaders</span><span class=\"token punctuation\">(</span>headers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> headerLength <span class=\"token operator\">=</span> Convert<span class=\"token punctuation\">.</span><span class=\"token function\">ToUInt16</span><span class=\"token punctuation\">(</span>packedHeaders<span class=\"token punctuation\">.</span>Length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">using</span> <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> output <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">MemoryStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  output<span class=\"token punctuation\">.</span><span class=\"token function\">WriteByte</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x01</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  output<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>BitConverter<span class=\"token punctuation\">.</span><span class=\"token function\">GetBytes</span><span class=\"token punctuation\">(</span>headerLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  output<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>packedHeaders<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  output<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span>Data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> output<span class=\"token punctuation\">.</span><span class=\"token function\">ToArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> <span class=\"token function\">packHeaders</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">IEnumerable<span class=\"token punctuation\">&lt;</span>KeyValuePair<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">string</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">string</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> headers<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//0 will disable dynamic table that we don't need anyways</span>\n  <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> encoder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">hpack<span class=\"token punctuation\">.</span>Encoder</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">using</span> <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> output <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">MemoryStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">using</span> <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> writer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">BinaryWriter</span><span class=\"token punctuation\">(</span>output<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">foreach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">value</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">in</span> headers<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    encoder<span class=\"token punctuation\">.</span><span class=\"token function\">EncodeHeader</span><span class=\"token punctuation\">(</span>writer<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">value</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> output<span class=\"token punctuation\">.</span><span class=\"token function\">ToArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>The first thing we do is add our one required header to the metadata: <code>content-length</code>. We then pack the headers. The <code>hpack</code> encoder is pretty easy to use. Passing that <code>0</code> into the constructor should disable some HPACK features that don't make sense in the context of SDBD.</p>\n<p>That gives us all the bits we need to write out a document. Version number: <code>0x01</code>. Header length as an unsigned 16-bit integer. The packed headers themselves. And finally the data.</p>\n<p>If I encode a file named <code>test.txt</code> with the content <code>This is a test. This is only a test.</code>, this is the output:</p>\n<pre class=\"language-text\" tabindex=\"0\"><code class=\"language-text\">0000\t01 17 00 00 89 21 ea 49  6a 4a d5 0e 92 ff 86 49   .....!.IjJ.....I\n0010\t50 95 d3 e5 3f 0f 0d 02  33 36 54 68 69 73 20 69   P...?...36This i\n0020\t73 20 61 20 74 65 73 74  2e 20 54 68 69 73 20 69   s a test. This i\n0030\t73 20 6f 6e 6c 79 20 61  20 74 65 73 74 2e         s only a test.</code></pre>\n<p>Looks promising. The first byte is the version, the next two decode to integer 23. The next 23 bytes look like the headers to me, and we can even see the content length 36 in the text. Finally there's the 36 bytes of data.</p>\n<h2 id=\"decoder\" tabindex=\"-1\">Decoder <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-09-02-The_Heart_of_the_Code/\">#</a></h2>\n<pre class=\"language-cs\" tabindex=\"0\"><code class=\"language-cs\"><span class=\"token keyword\">public</span> <span class=\"token return-type class-name\">Document</span> <span class=\"token function\">Decode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">using</span> <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> input <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">MemoryStream</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> version <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">ReadByte</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> version <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token number\">0x01</span> <span class=\"token operator\">=></span> <span class=\"token function\">DecodeV1</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    _ <span class=\"token operator\">=></span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Exception</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unsupported version\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token return-type class-name\">Document</span> <span class=\"token function\">DecodeV1</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Stream</span> stream<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> headerLengthBytes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\"><span class=\"token keyword\">byte</span></span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  stream<span class=\"token punctuation\">.</span><span class=\"token function\">ReadExactly</span><span class=\"token punctuation\">(</span>headerLengthBytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> headerLength <span class=\"token operator\">=</span> BitConverter<span class=\"token punctuation\">.</span><span class=\"token function\">ToUInt16</span><span class=\"token punctuation\">(</span>headerLengthBytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> headerBytes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\"><span class=\"token keyword\">byte</span></span><span class=\"token punctuation\">[</span>headerLength<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  stream<span class=\"token punctuation\">.</span><span class=\"token function\">ReadExactly</span><span class=\"token punctuation\">(</span>headerBytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> headers <span class=\"token operator\">=</span> <span class=\"token function\">unpackHeaders</span><span class=\"token punctuation\">(</span>headerBytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   \n  <span class=\"token class-name\"><span class=\"token keyword\">string</span></span> contentLengthString<span class=\"token punctuation\">;</span>\n  headers<span class=\"token punctuation\">.</span><span class=\"token function\">Remove</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"content-length\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">out</span> contentLengthString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> contentLength <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">.</span><span class=\"token function\">Parse</span><span class=\"token punctuation\">(</span>contentLengthString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\"><span class=\"token keyword\">byte</span></span><span class=\"token punctuation\">[</span>contentLength<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  stream<span class=\"token punctuation\">.</span><span class=\"token function\">ReadExactly</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Document</span><span class=\"token punctuation\">(</span>headers<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>To decode we first read the version byte. If the version is the only version we have implemented now, we jump into the real implementation. (Throw an exception otherwise.)</p>\n<p>We read the next two bytes to get the header length. We read that number of bytes to get the encoded headers. We decode the headers, extract <code>content-length</code>, and read that number of bytes as the data. Then we pack it up in our <code>Document</code> data structure and send it back.</p>\n<p>I left out the implementation of <code>unpackHeaders</code> here because it's mildly confusing if you're not familiar with old .NET patterns. You can find it with the complete <a href=\"https://github.com/cheddarcrisp/sdbd-demo\">source for this implementation on GitHub</a>.</p>\n<h2 id=\"and-now\" tabindex=\"-1\">And now... <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-09-02-The_Heart_of_the_Code/\">#</a></h2>\n<p>It's time for a break. I have successfully created a brand new data format. Or at least stitched one together like Frankenstein's monster. I have a working implementation that can encode and decode the format, albeit with only one header implemented.</p>\n<p>I'm already building a list of improvements. I'm not planning on tackling them for a bit. First I want to hear other people's feedback. Since this is the internet, somebody will no doubt tell me that something like this already exists. If that's true, great! I'll be sure to link it here for anybody interested.</p>\n<p>Either way I certainly haven't wasted my time, and I hope you don't feel like you've wasted yours. I think the process of developing the SDBD format and a proof of concept was a valuable learning experience on its own. I want to hear feedback, so feel free to log issues on GitHub or find me on the Fediverse.</p>\n<p>If you like SDBD and want to use it, go for it! I think the format itself is sound. The demo implementation has at least one security issue, so use it with caution.</p>\n",
			"date_published": "2024-01-09T00:00:00Z"
		}
		,
		{
			"id": "https://crispbyte.dev/blog/2024-01-09-01-Building_A_Proof_of_Concept/",
			"url": "https://crispbyte.dev/blog/2024-01-09-01-Building_A_Proof_of_Concept/",
			"title": "Building a Proof of Concept",
			"content_html": "<p>The format certainly looks sound. Could there be any surprises when we try to implement it? There's one way to find out. I'll write a Proof of Concept. Finally, we get to the code!</p>\n<h2 id=\"looking-sharp\" tabindex=\"-1\">Looking Sharp <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-09-01-Building_A_Proof_of_Concept/\">#</a></h2>\n<p>My career experience has mostly been with .NET and web development. My latest job had me coding in Ruby on Rails. After a two year absence, I'm anxious to get back into the world of .NET. I'm going to do the implementation in C# with .NET 8.0.</p>\n<h2 id=\"start-at-the-interface\" tabindex=\"-1\">Start at the interface <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-09-01-Building_A_Proof_of_Concept/\">#</a></h2>\n<p>When I code, I always start at the interfaces. Whether it's the user interface (UI) or the application programming interfaces (APIs), starting at the interfaces sets up good boundaries that guide good design. I'll start by defining the contract for an API that encodes and decodes SDBD data.</p>\n<pre class=\"language-cs\" tabindex=\"0\"><code class=\"language-cs\"><span class=\"token keyword\">namespace</span> <span class=\"token namespace\">SDBD</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">ICodec</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token return-type class-name\">Document</span> <span class=\"token function\">Decode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token return-type class-name\"><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> <span class=\"token function\">Encode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Document</span> document<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">record</span> <span class=\"token class-name\">Document</span><span class=\"token punctuation\">(</span>\n  <span class=\"token class-name\">Dictionary<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">string</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">string</span><span class=\"token punctuation\">></span></span> Metadata<span class=\"token punctuation\">,</span>\n  <span class=\"token class-name\"><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> Data\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"a-basic-demo\" tabindex=\"-1\">A basic demo <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-09-01-Building_A_Proof_of_Concept/\">#</a></h2>\n<p>The demo program will be a command line encoder/decoder. To encode, pass a file path on its own or with <code>-e</code> as the first parameter. The program will encode the file to SDBD with the original filename embedded and write a file with a <code>.sdbd</code> extension. To decode, pass <code>-d</code> as the first parameter and the path to an <code>.sdbd</code> file. It will write a file with the original data and the original filename.</p>\n<pre class=\"language-cs\" tabindex=\"0\"><code class=\"language-cs\"><span class=\"token class-name\">SDBD<span class=\"token punctuation\">.</span>ICodec</span> codec <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">SDBD<span class=\"token punctuation\">.</span>Codec</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span>encode<span class=\"token punctuation\">,</span> filepath<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token function\">ParseArgs</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\"><span class=\"token keyword\">var</span></span> inputData <span class=\"token operator\">=</span> File<span class=\"token punctuation\">.</span><span class=\"token function\">ReadAllBytes</span><span class=\"token punctuation\">(</span>filepath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\"><span class=\"token keyword\">var</span></span> filename <span class=\"token operator\">=</span> Path<span class=\"token punctuation\">.</span><span class=\"token function\">GetFileName</span><span class=\"token punctuation\">(</span>filepath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>encode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">SDBD<span class=\"token punctuation\">.</span>Document</span> document <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token punctuation\">{</span> <span class=\"token string\">\"content-name\"</span><span class=\"token punctuation\">,</span> filename <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    inputData\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> outputData <span class=\"token operator\">=</span> codec<span class=\"token punctuation\">.</span><span class=\"token function\">Encode</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  File<span class=\"token punctuation\">.</span><span class=\"token function\">WriteAllBytes</span><span class=\"token punctuation\">(</span><span class=\"token interpolation-string\"><span class=\"token string\">$\"</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span><span class=\"token expression language-csharp\">filename</span><span class=\"token punctuation\">}</span></span><span class=\"token string\">.sdbd\"</span></span><span class=\"token punctuation\">,</span> outputData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> document <span class=\"token operator\">=</span> codec<span class=\"token punctuation\">.</span><span class=\"token function\">Decode</span><span class=\"token punctuation\">(</span>inputData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  File<span class=\"token punctuation\">.</span><span class=\"token function\">WriteAllBytes</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span>Metadata<span class=\"token punctuation\">[</span><span class=\"token string\">\"content-name\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">.</span>Data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token return-type class-name\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> encode<span class=\"token punctuation\">,</span> <span class=\"token keyword\">string</span> filepath<span class=\"token punctuation\">)</span></span> <span class=\"token function\">ParseArgs</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> args <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token class-name\"><span class=\"token keyword\">var</span></span> filepath<span class=\"token punctuation\">]</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> filepath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">[</span><span class=\"token string\">\"-d\"</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> filepath<span class=\"token punctuation\">]</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> filepath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">[</span><span class=\"token string\">\"-e\"</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> filepath<span class=\"token punctuation\">]</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> filepath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    _ <span class=\"token operator\">=></span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Exception</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I don't like those arguments\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"first-run\" tabindex=\"-1\">First run <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-09-01-Building_A_Proof_of_Concept/\">#</a></h2>\n<p>I'll mock up an implementation of the interface to make sure the program is working. All it will do is echo back the data it's given, and give the document the name <code>text.txt</code>.</p>\n<pre class=\"language-cs\" tabindex=\"0\"><code class=\"language-cs\"><span class=\"token keyword\">namespace</span> <span class=\"token namespace\">SDBD</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Codec</span> <span class=\"token punctuation\">:</span> <span class=\"token type-list\"><span class=\"token class-name\">ICodec</span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\">Document</span> <span class=\"token function\">Decode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>\n      <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">{</span> <span class=\"token string\">\"content-name\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"text.txt\"</span> <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      data\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span> <span class=\"token function\">Encode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Document</span> document<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> document<span class=\"token punctuation\">.</span>Data<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>If we run the program on any file, it will output the same file with the <code>.sdbd</code> extension added. Run the program on a file with the <code>-d</code> parameter and it will output the same data with the file name <code>text.txt</code>. Looking good so far.</p>\n",
			"date_published": "2024-01-09T00:00:00Z"
		}
		,
		{
			"id": "https://crispbyte.dev/blog/2024-01-07-03-Data_Format/",
			"url": "https://crispbyte.dev/blog/2024-01-07-03-Data_Format/",
			"title": "What Does SDBD Actually Look Like?",
			"content_html": "<p>To turn the semantics into a real file format, we need to define what they look like as actual data. How do you write an SDBD to a stream or a disk? How do we turn our HTTP-like semantics into a real document? That question almost answers itself. I'll keep stealing from HTTP.</p>\n<h2 id=\"consider-the-options\" tabindex=\"-1\">Consider the options <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-07-03-Data_Format/\">#</a></h2>\n<p>There are three versions of HTTP that each represent headers in a different format. HTTP/1.1 uses a human-readable plain text format. It's basically the format you'll see in browser development tools and blog posts about HTTP headers. HTTP/2 uses a compressible binary format called HPACK. HTTP/3 uses a variant of HPACK called QPACK that's designed to be less trouble for the underlying QUIC protocol.</p>\n<p>I'm going to decide that SDBD will be a binary format. No part of it needs to be plain text. I'm going to choose HPACK over QPACK. Mostly that's because I think it should be easier to implement the proof of concept with HPACK due to available tools.</p>\n<h2 id=\"represent\" tabindex=\"-1\">Represent <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-07-03-Data_Format/\">#</a></h2>\n<p>It's time to put it together. I already have plans for updating the format, so the very first byte of SDBD will be a version number. We'll start simply with <code>0x01</code>. The rest of this section will describe a <code>version 1</code> document.</p>\n<p>Next comes the metadata. We need to know how long the metadata is, so we'll use two bytes to store an unsigned int to tell us the length of the metadata section in bytes. (But what happens if the metadata is more than 64KB? We'll worry about that later.) The metadata headers will be encoded with HPACK.</p>\n<p>After the metadata comes the data, which better be the exact length defined by <code>content-length</code>, or bad things will happen.</p>\n<p>That's it. If we encode the original example with this format, this is the result:</p>\n<pre class=\"language-text\" tabindex=\"0\"><code class=\"language-text\">0000\t01 3a 00 00 89 21 ea 49  6a 4a d5 0e 92 ff 8d 5f   .:...!.IjJ....._\n0010\tff f8 20 74 d7 41 57 4f  94 af 1d 9f 0f 0b 02 62   .. t.AWO.......b\n0020\t72 0f 10 94 49 7c a5 8a  e8 19 aa fb 50 93 8e c4   r...I|......P...\n0030\t15 30 5a 85 86 82 18 df  0f 0d 02 39 35 a1 20 04   .0Z........95. .\n0040\t00 20 50 6e eb 2b e9 96  6c 96 ac 25 3e a8 69 22   . Pn.+..l..%>.i\"\n0050\t88 0b ea c9 42 ee de f8  24 4d b3 bd 08 d5 80 db   ....B...$M......\n0060\tf0 b9 02 31 a3 be 91 b7  65 bd 28 82 7f 92 1c 88   ...1....e.(.....\n0070\tf2 38 1d eb 56 54 b9 93  d3 59 62 6a 7f 65 30 f4   .8..VT...Ybj.e0.\n0080\tdd 5c 62 80 01 74 42 12  6e 34 a8 1c e5 9d f4 91   .\\b..tB.n4......\n0090\t3c 34 83 10 00 1a 70 2e  bb f5 aa 01               <4....p.....</code></pre>\n<p>It is finally time to get to the good part. Let's write some code.</p>\n",
			"date_published": "2024-01-07T00:00:00Z"
		}
		,
		{
			"id": "https://crispbyte.dev/blog/2024-01-07-02-Semantics/",
			"url": "https://crispbyte.dev/blog/2024-01-07-02-Semantics/",
			"title": "Semantics of SDBD",
			"content_html": "<p>To really start bringing this new data format to life, we need to talk about what's in it. Establishing the semantics of a format gives us the terms and concepts we need to talk about the format abstractly before we get to any concrete details.</p>\n<h2 id=\"start-with-the-data\" tabindex=\"-1\">Start with the data <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-07-02-Semantics/\">#</a></h2>\n<p>Let's start with a simple example. Here is a base64 encoding of some arbitrary data.</p>\n<pre class=\"language-text\" tabindex=\"0\"><code class=\"language-text\">oSAEACBQbusr6ZZslqwlPqhpIogL6slC7t74JE2zvQjVgNvwuQIxo76Rt2W9KIJ/khyI8jgd61ZU\nuZPTWWJqf2Uw9N1cYoABdEISbjSoHOWd9JE8NIMQABpwLrv1qgE=</code></pre>\n<p>How does somebody make sense of this? On my system I know how I created this file and I know the filename, so I know exactly what it is. But without that, what do you do? Let's use the <code>file</code> tool to make a guess by running <code>file -i</code> on it.</p>\n<pre class=\"language-text\" tabindex=\"0\"><code class=\"language-text\">application/octet-stream; charset=binary</code></pre>\n<p>That's not useful. The output might as well have been</p>\n<pre class=\"language-text\" tabindex=\"0\"><code class=\"language-text\">¯\\_(ツ)_/¯</code></pre>\n<h2 id=\"add-the-metadata\" tabindex=\"-1\">Add the metadata <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-07-02-Semantics/\">#</a></h2>\n<p>The only way you're going to make sense of this data is if I start giving you more information. The first thing I'm going to tell you is that this is compressed with brotli.</p>\n<p>The format will use the concept that data encoding is different from the file type. Generally that will mean we can compress the data without having to nest our metadata. I'll add a metadata field to the format that tells you the encoding.</p>\n<pre class=\"language-text\" tabindex=\"0\"><code class=\"language-text\">content-encoding: br</code></pre>\n<p>If you decompress the data and look at the result, it will immediately become apparent what the file is. For the sake of continuing this article, let's pretend that we're not human beings with advanced pattern recognition capabilities, but a computer that's not being allowed to guess.</p>\n<p>In order to understand this file, the next thing you need is to know the file type. Running <code>file -i</code> on the decompressed file gets it right this time, but we're no longer allowed to guess. I'll give you another metadata field that tells you the file type.</p>\n<pre class=\"language-text\" tabindex=\"0\"><code class=\"language-text\">content-type: text/plain; charset=us-ascii</code></pre>\n<p>It's just plain ASCII text! Now that you have this information, you can properly interpret the data. Go ahead and try decoding the data now.</p>\n<h2 id=\"this-looks-familiar\" tabindex=\"-1\">This looks familiar... <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-07-02-Semantics/\">#</a></h2>\n<p>Go ahead and give yourself a gold star if you recognize what I've been doing so far. That's right, I am straight up ripping off HTTP. The metadata of SDBD will be a list of headers semantically equivalent to HTTP headers. I'll even say, for the sake of implementation, we'll follow similar rules:</p>\n<ol>\n<li>Headers names are case insensitive</li>\n<li>Multiple headers can have the same name</li>\n<li>The order of headers is significant and must be preserved\nNote that when we get to the proof of concept, I won't be following any of these rules.</li>\n</ol>\n<h2 id=\"what-s-your-name\" tabindex=\"-1\">What's your name? <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-07-02-Semantics/\">#</a></h2>\n<p>I do need to make a few tweaks. Solving part of our original problem requires storing the filename. There aren't any standard HTTP headers that are exactly meant for this. <code>content-disposition</code> can contain a filename, but its real purpose is something else. That header will normally look something like this:</p>\n<pre class=\"language-text\" tabindex=\"0\"><code class=\"language-text\">content-disposition: attachment; filename=\"filename.jpg\"</code></pre>\n<p>This header is meant to tell a browser whether the response should be displayed in the browser or downloaded. SDBD isn't meant specifically for browsers so we would be including useless information just to store a filename in an awkwardly formatted field.</p>\n<p>I'll create a new header for this.</p>\n<pre class=\"language-text\" tabindex=\"0\"><code class=\"language-text\">content-name: sample.txt</code></pre>\n<h2 id=\"when-does-it-end\" tabindex=\"-1\">When does it end? <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-07-02-Semantics/\">#</a></h2>\n<p>We need a way to identify exactly what size the data is. <code>content-length</code> is technically optional in HTTP, since you can mark the end of a response by closing the connection. But we're not making any assumptions about the context of an SDBD, so we can't assume a connection to close. I'd rather not try to create a marker for the end of the data, so I'll say that <code>content-length</code> is required.</p>\n<h2 id=\"what-do-we-actually-need\" tabindex=\"-1\">What do we actually need? <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-07-02-Semantics/\">#</a></h2>\n<p>Let's wrap this up by deciding what's required, what <em>should</em> be present, and what's optional. I've already decided that <code>content-length</code> is required, and I think that's the only thing we absolutely need.</p>\n<p>I think <code>content-type</code> should be present, but I don't want to make it an absolute requirement. I don't see a use case where you wouldn't want <code>content-type</code>, but let's not limit ourselves unnecessarily. Also, since I haven't explicitly stated it yet, the value of <code>content-type</code> must be a MIME type.</p>\n<p>If the documented is encoded (compressed), <code>content-encoding</code> must also be present unless the metadata is specifically describing the encoded data. I don't want to define exactly what the value of <code>content-encoding</code> must be, other than that implementations should support the common values used on the web: <code>gzip</code>, <code>deflate</code>, and <code>br</code>.</p>\n<p>Other encodings should perhaps use their own MIME type, such as <code>application/x-bzip2</code>. I'm not ready to set that in stone in case somebody comes up with a use case for encoding that isn't about compression.</p>\n<p>The data should have a good identifier as well, so we should give it a filename with <code>content-name</code>, a URI with <code>content-location</code>, or both.</p>\n<p>Anything else is optional.</p>\n<p>With that, here is the complete metadata for the example document.</p>\n<pre class=\"language-text\" tabindex=\"0\"><code class=\"language-text\">content-name: sample.txt\ncontent-encoding: br\ncontent-type: text/plain; charset=us-ascii\ncontent-length: 95</code></pre>\n<h2 id=\"sounds-simple-enough\" tabindex=\"-1\">Sounds simple enough <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-07-02-Semantics/\">#</a></h2>\n<p>That's all the information a computer would need to interpret the example data. The format consists of the data combined with metadata that is a list of headers semantically similar to HTTP headers. There's one header required for the length of the data, and a few others that are commended. That's all there is to it.</p>\n<p>Now we need to define what this will all look like in a real binary format.</p>\n",
			"date_published": "2024-01-07T00:00:00Z"
		}
		,
		{
			"id": "https://crispbyte.dev/blog/2024-01-07-01-SDBD/",
			"url": "https://crispbyte.dev/blog/2024-01-07-01-SDBD/",
			"title": "Let&#39;s Create a Data Format",
			"content_html": "<p>I have a problem. I want to be able to transfer self-contained binary data with metadata through a variety of protocols with no knowledge of the binary data's format or the protocol being used for transfer.</p>\n<p>Or in other words, I want to be able to send files anywhere without losing the filename.</p>\n<p>That's a bit simpler than my actual goal, but I think this is a problem every software developer has considered at some point. We've all asked the question, &quot;Why isn't the filename attached to the file?&quot; or slightly more advanced, &quot;Why isn't the file format attached to the file?&quot;</p>\n<p>The answer isn't all that complicated.</p>\n<ul>\n<li>Any file transfer protocol ever invented can pass the filename with the file</li>\n<li>File extensions are Good Enough for identifying the file format</li>\n<li>We have good tools for guessing the format if the filename is missing</li>\n<li>As human beings we can use context to guess the format and &quot;fix&quot; the extension</li>\n</ul>\n<p>But I'm going to declare that Good Enough isn't good enough. Perhaps this is the metadata that is most useful for files, but it's not the only useful metadata. It also depends on the transfer protocol to preserve the metadata. What if I don't want to rely on a specific protocol?</p>\n<p>And so, knowing full well that this is likely to go nowhere and that solutions to this problem almost certainly already exist, I'm going to set out to create a new data format that encapsulates data and metadata into a single file.</p>\n<h2 id=\"the-hard-problem\" tabindex=\"-1\">The hard problem <a class=\"header-anchor\" href=\"https://crispbyte.dev/blog/2024-01-07-01-SDBD/\">#</a></h2>\n<p>The first thing to do is give my new format a name. After some deliberation, I'm going to settle on Self-described Binary Document or SDBD for short. It's contains arbitrary binary data. It's a document and not a file because it could live anywhere. And the whole purpose is to let the document describe its own contents. Now that I've tackled <a href=\"https://martinfowler.com/bliki/TwoHardThings.html\">one of the hard problems</a>, the rest should be easy.</p>\n<p>The next step is to talk about how we talk about the format. How is it structured and what concepts do we use to build it?</p>\n",
			"date_published": "2024-01-07T00:00:00Z"
		}
		
	]
}
